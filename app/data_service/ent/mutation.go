// Code generated by entc, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"github.com/Jecosine/alioth-kratos/app/data_service/ent/announcement"
	"github.com/Jecosine/alioth-kratos/app/data_service/ent/judgerecord"
	"github.com/Jecosine/alioth-kratos/app/data_service/ent/predicate"
	"github.com/Jecosine/alioth-kratos/app/data_service/ent/problem"
	"github.com/Jecosine/alioth-kratos/app/data_service/ent/tag"
	"github.com/Jecosine/alioth-kratos/app/data_service/ent/team"
	"github.com/Jecosine/alioth-kratos/app/data_service/ent/todo"
	"github.com/Jecosine/alioth-kratos/app/data_service/ent/user"

	"entgo.io/ent"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeAnnouncement = "Announcement"
	TypeJudgeRecord  = "JudgeRecord"
	TypeProblem      = "Problem"
	TypeTag          = "Tag"
	TypeTeam         = "Team"
	TypeTodo         = "Todo"
	TypeUser         = "User"
)

// AnnouncementMutation represents an operation that mutates the Announcement nodes in the graph.
type AnnouncementMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	title         *string
	content       *string
	createdTime   *time.Time
	modifiedTime  *time.Time
	clearedFields map[string]struct{}
	author        *int64
	clearedauthor bool
	team          *int64
	clearedteam   bool
	done          bool
	oldValue      func(context.Context) (*Announcement, error)
	predicates    []predicate.Announcement
}

var _ ent.Mutation = (*AnnouncementMutation)(nil)

// announcementOption allows management of the mutation configuration using functional options.
type announcementOption func(*AnnouncementMutation)

// newAnnouncementMutation creates new mutation for the Announcement entity.
func newAnnouncementMutation(c config, op Op, opts ...announcementOption) *AnnouncementMutation {
	m := &AnnouncementMutation{
		config:        c,
		op:            op,
		typ:           TypeAnnouncement,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAnnouncementID sets the ID field of the mutation.
func withAnnouncementID(id int64) announcementOption {
	return func(m *AnnouncementMutation) {
		var (
			err   error
			once  sync.Once
			value *Announcement
		)
		m.oldValue = func(ctx context.Context) (*Announcement, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Announcement.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAnnouncement sets the old Announcement of the mutation.
func withAnnouncement(node *Announcement) announcementOption {
	return func(m *AnnouncementMutation) {
		m.oldValue = func(context.Context) (*Announcement, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AnnouncementMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AnnouncementMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Announcement entities.
func (m *AnnouncementMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AnnouncementMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AnnouncementMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Announcement.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTitle sets the "title" field.
func (m *AnnouncementMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *AnnouncementMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the Announcement entity.
// If the Announcement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AnnouncementMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *AnnouncementMutation) ResetTitle() {
	m.title = nil
}

// SetContent sets the "content" field.
func (m *AnnouncementMutation) SetContent(s string) {
	m.content = &s
}

// Content returns the value of the "content" field in the mutation.
func (m *AnnouncementMutation) Content() (r string, exists bool) {
	v := m.content
	if v == nil {
		return
	}
	return *v, true
}

// OldContent returns the old "content" field's value of the Announcement entity.
// If the Announcement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AnnouncementMutation) OldContent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContent: %w", err)
	}
	return oldValue.Content, nil
}

// ResetContent resets all changes to the "content" field.
func (m *AnnouncementMutation) ResetContent() {
	m.content = nil
}

// SetCreatedTime sets the "createdTime" field.
func (m *AnnouncementMutation) SetCreatedTime(t time.Time) {
	m.createdTime = &t
}

// CreatedTime returns the value of the "createdTime" field in the mutation.
func (m *AnnouncementMutation) CreatedTime() (r time.Time, exists bool) {
	v := m.createdTime
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedTime returns the old "createdTime" field's value of the Announcement entity.
// If the Announcement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AnnouncementMutation) OldCreatedTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedTime: %w", err)
	}
	return oldValue.CreatedTime, nil
}

// ResetCreatedTime resets all changes to the "createdTime" field.
func (m *AnnouncementMutation) ResetCreatedTime() {
	m.createdTime = nil
}

// SetModifiedTime sets the "modifiedTime" field.
func (m *AnnouncementMutation) SetModifiedTime(t time.Time) {
	m.modifiedTime = &t
}

// ModifiedTime returns the value of the "modifiedTime" field in the mutation.
func (m *AnnouncementMutation) ModifiedTime() (r time.Time, exists bool) {
	v := m.modifiedTime
	if v == nil {
		return
	}
	return *v, true
}

// OldModifiedTime returns the old "modifiedTime" field's value of the Announcement entity.
// If the Announcement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AnnouncementMutation) OldModifiedTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldModifiedTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldModifiedTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldModifiedTime: %w", err)
	}
	return oldValue.ModifiedTime, nil
}

// ResetModifiedTime resets all changes to the "modifiedTime" field.
func (m *AnnouncementMutation) ResetModifiedTime() {
	m.modifiedTime = nil
}

// SetAuthorID sets the "author" edge to the User entity by id.
func (m *AnnouncementMutation) SetAuthorID(id int64) {
	m.author = &id
}

// ClearAuthor clears the "author" edge to the User entity.
func (m *AnnouncementMutation) ClearAuthor() {
	m.clearedauthor = true
}

// AuthorCleared reports if the "author" edge to the User entity was cleared.
func (m *AnnouncementMutation) AuthorCleared() bool {
	return m.clearedauthor
}

// AuthorID returns the "author" edge ID in the mutation.
func (m *AnnouncementMutation) AuthorID() (id int64, exists bool) {
	if m.author != nil {
		return *m.author, true
	}
	return
}

// AuthorIDs returns the "author" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AuthorID instead. It exists only for internal usage by the builders.
func (m *AnnouncementMutation) AuthorIDs() (ids []int64) {
	if id := m.author; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAuthor resets all changes to the "author" edge.
func (m *AnnouncementMutation) ResetAuthor() {
	m.author = nil
	m.clearedauthor = false
}

// SetTeamID sets the "team" edge to the Team entity by id.
func (m *AnnouncementMutation) SetTeamID(id int64) {
	m.team = &id
}

// ClearTeam clears the "team" edge to the Team entity.
func (m *AnnouncementMutation) ClearTeam() {
	m.clearedteam = true
}

// TeamCleared reports if the "team" edge to the Team entity was cleared.
func (m *AnnouncementMutation) TeamCleared() bool {
	return m.clearedteam
}

// TeamID returns the "team" edge ID in the mutation.
func (m *AnnouncementMutation) TeamID() (id int64, exists bool) {
	if m.team != nil {
		return *m.team, true
	}
	return
}

// TeamIDs returns the "team" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TeamID instead. It exists only for internal usage by the builders.
func (m *AnnouncementMutation) TeamIDs() (ids []int64) {
	if id := m.team; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTeam resets all changes to the "team" edge.
func (m *AnnouncementMutation) ResetTeam() {
	m.team = nil
	m.clearedteam = false
}

// Where appends a list predicates to the AnnouncementMutation builder.
func (m *AnnouncementMutation) Where(ps ...predicate.Announcement) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *AnnouncementMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Announcement).
func (m *AnnouncementMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AnnouncementMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.title != nil {
		fields = append(fields, announcement.FieldTitle)
	}
	if m.content != nil {
		fields = append(fields, announcement.FieldContent)
	}
	if m.createdTime != nil {
		fields = append(fields, announcement.FieldCreatedTime)
	}
	if m.modifiedTime != nil {
		fields = append(fields, announcement.FieldModifiedTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AnnouncementMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case announcement.FieldTitle:
		return m.Title()
	case announcement.FieldContent:
		return m.Content()
	case announcement.FieldCreatedTime:
		return m.CreatedTime()
	case announcement.FieldModifiedTime:
		return m.ModifiedTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AnnouncementMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case announcement.FieldTitle:
		return m.OldTitle(ctx)
	case announcement.FieldContent:
		return m.OldContent(ctx)
	case announcement.FieldCreatedTime:
		return m.OldCreatedTime(ctx)
	case announcement.FieldModifiedTime:
		return m.OldModifiedTime(ctx)
	}
	return nil, fmt.Errorf("unknown Announcement field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AnnouncementMutation) SetField(name string, value ent.Value) error {
	switch name {
	case announcement.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case announcement.FieldContent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContent(v)
		return nil
	case announcement.FieldCreatedTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedTime(v)
		return nil
	case announcement.FieldModifiedTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetModifiedTime(v)
		return nil
	}
	return fmt.Errorf("unknown Announcement field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AnnouncementMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AnnouncementMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AnnouncementMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Announcement numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AnnouncementMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AnnouncementMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AnnouncementMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Announcement nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AnnouncementMutation) ResetField(name string) error {
	switch name {
	case announcement.FieldTitle:
		m.ResetTitle()
		return nil
	case announcement.FieldContent:
		m.ResetContent()
		return nil
	case announcement.FieldCreatedTime:
		m.ResetCreatedTime()
		return nil
	case announcement.FieldModifiedTime:
		m.ResetModifiedTime()
		return nil
	}
	return fmt.Errorf("unknown Announcement field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AnnouncementMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.author != nil {
		edges = append(edges, announcement.EdgeAuthor)
	}
	if m.team != nil {
		edges = append(edges, announcement.EdgeTeam)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AnnouncementMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case announcement.EdgeAuthor:
		if id := m.author; id != nil {
			return []ent.Value{*id}
		}
	case announcement.EdgeTeam:
		if id := m.team; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AnnouncementMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AnnouncementMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AnnouncementMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedauthor {
		edges = append(edges, announcement.EdgeAuthor)
	}
	if m.clearedteam {
		edges = append(edges, announcement.EdgeTeam)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AnnouncementMutation) EdgeCleared(name string) bool {
	switch name {
	case announcement.EdgeAuthor:
		return m.clearedauthor
	case announcement.EdgeTeam:
		return m.clearedteam
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AnnouncementMutation) ClearEdge(name string) error {
	switch name {
	case announcement.EdgeAuthor:
		m.ClearAuthor()
		return nil
	case announcement.EdgeTeam:
		m.ClearTeam()
		return nil
	}
	return fmt.Errorf("unknown Announcement unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AnnouncementMutation) ResetEdge(name string) error {
	switch name {
	case announcement.EdgeAuthor:
		m.ResetAuthor()
		return nil
	case announcement.EdgeTeam:
		m.ResetTeam()
		return nil
	}
	return fmt.Errorf("unknown Announcement edge %s", name)
}

// JudgeRecordMutation represents an operation that mutates the JudgeRecord nodes in the graph.
type JudgeRecordMutation struct {
	config
	op             Op
	typ            string
	id             *int64
	judge_time     *time.Time
	finished_time  *time.Time
	time_cost      *int64
	addtime_cost   *int64
	memory_cost    *int64
	addmemory_cost *int64
	status         *int64
	addstatus      *int64
	clearedFields  map[string]struct{}
	user           map[int64]struct{}
	removeduser    map[int64]struct{}
	cleareduser    bool
	done           bool
	oldValue       func(context.Context) (*JudgeRecord, error)
	predicates     []predicate.JudgeRecord
}

var _ ent.Mutation = (*JudgeRecordMutation)(nil)

// judgerecordOption allows management of the mutation configuration using functional options.
type judgerecordOption func(*JudgeRecordMutation)

// newJudgeRecordMutation creates new mutation for the JudgeRecord entity.
func newJudgeRecordMutation(c config, op Op, opts ...judgerecordOption) *JudgeRecordMutation {
	m := &JudgeRecordMutation{
		config:        c,
		op:            op,
		typ:           TypeJudgeRecord,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withJudgeRecordID sets the ID field of the mutation.
func withJudgeRecordID(id int64) judgerecordOption {
	return func(m *JudgeRecordMutation) {
		var (
			err   error
			once  sync.Once
			value *JudgeRecord
		)
		m.oldValue = func(ctx context.Context) (*JudgeRecord, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().JudgeRecord.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withJudgeRecord sets the old JudgeRecord of the mutation.
func withJudgeRecord(node *JudgeRecord) judgerecordOption {
	return func(m *JudgeRecordMutation) {
		m.oldValue = func(context.Context) (*JudgeRecord, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m JudgeRecordMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m JudgeRecordMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of JudgeRecord entities.
func (m *JudgeRecordMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *JudgeRecordMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *JudgeRecordMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().JudgeRecord.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetJudgeTime sets the "judge_time" field.
func (m *JudgeRecordMutation) SetJudgeTime(t time.Time) {
	m.judge_time = &t
}

// JudgeTime returns the value of the "judge_time" field in the mutation.
func (m *JudgeRecordMutation) JudgeTime() (r time.Time, exists bool) {
	v := m.judge_time
	if v == nil {
		return
	}
	return *v, true
}

// OldJudgeTime returns the old "judge_time" field's value of the JudgeRecord entity.
// If the JudgeRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JudgeRecordMutation) OldJudgeTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldJudgeTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldJudgeTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldJudgeTime: %w", err)
	}
	return oldValue.JudgeTime, nil
}

// ResetJudgeTime resets all changes to the "judge_time" field.
func (m *JudgeRecordMutation) ResetJudgeTime() {
	m.judge_time = nil
}

// SetFinishedTime sets the "finished_time" field.
func (m *JudgeRecordMutation) SetFinishedTime(t time.Time) {
	m.finished_time = &t
}

// FinishedTime returns the value of the "finished_time" field in the mutation.
func (m *JudgeRecordMutation) FinishedTime() (r time.Time, exists bool) {
	v := m.finished_time
	if v == nil {
		return
	}
	return *v, true
}

// OldFinishedTime returns the old "finished_time" field's value of the JudgeRecord entity.
// If the JudgeRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JudgeRecordMutation) OldFinishedTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFinishedTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFinishedTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFinishedTime: %w", err)
	}
	return oldValue.FinishedTime, nil
}

// ResetFinishedTime resets all changes to the "finished_time" field.
func (m *JudgeRecordMutation) ResetFinishedTime() {
	m.finished_time = nil
}

// SetTimeCost sets the "time_cost" field.
func (m *JudgeRecordMutation) SetTimeCost(i int64) {
	m.time_cost = &i
	m.addtime_cost = nil
}

// TimeCost returns the value of the "time_cost" field in the mutation.
func (m *JudgeRecordMutation) TimeCost() (r int64, exists bool) {
	v := m.time_cost
	if v == nil {
		return
	}
	return *v, true
}

// OldTimeCost returns the old "time_cost" field's value of the JudgeRecord entity.
// If the JudgeRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JudgeRecordMutation) OldTimeCost(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTimeCost is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTimeCost requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTimeCost: %w", err)
	}
	return oldValue.TimeCost, nil
}

// AddTimeCost adds i to the "time_cost" field.
func (m *JudgeRecordMutation) AddTimeCost(i int64) {
	if m.addtime_cost != nil {
		*m.addtime_cost += i
	} else {
		m.addtime_cost = &i
	}
}

// AddedTimeCost returns the value that was added to the "time_cost" field in this mutation.
func (m *JudgeRecordMutation) AddedTimeCost() (r int64, exists bool) {
	v := m.addtime_cost
	if v == nil {
		return
	}
	return *v, true
}

// ResetTimeCost resets all changes to the "time_cost" field.
func (m *JudgeRecordMutation) ResetTimeCost() {
	m.time_cost = nil
	m.addtime_cost = nil
}

// SetMemoryCost sets the "memory_cost" field.
func (m *JudgeRecordMutation) SetMemoryCost(i int64) {
	m.memory_cost = &i
	m.addmemory_cost = nil
}

// MemoryCost returns the value of the "memory_cost" field in the mutation.
func (m *JudgeRecordMutation) MemoryCost() (r int64, exists bool) {
	v := m.memory_cost
	if v == nil {
		return
	}
	return *v, true
}

// OldMemoryCost returns the old "memory_cost" field's value of the JudgeRecord entity.
// If the JudgeRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JudgeRecordMutation) OldMemoryCost(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMemoryCost is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMemoryCost requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMemoryCost: %w", err)
	}
	return oldValue.MemoryCost, nil
}

// AddMemoryCost adds i to the "memory_cost" field.
func (m *JudgeRecordMutation) AddMemoryCost(i int64) {
	if m.addmemory_cost != nil {
		*m.addmemory_cost += i
	} else {
		m.addmemory_cost = &i
	}
}

// AddedMemoryCost returns the value that was added to the "memory_cost" field in this mutation.
func (m *JudgeRecordMutation) AddedMemoryCost() (r int64, exists bool) {
	v := m.addmemory_cost
	if v == nil {
		return
	}
	return *v, true
}

// ResetMemoryCost resets all changes to the "memory_cost" field.
func (m *JudgeRecordMutation) ResetMemoryCost() {
	m.memory_cost = nil
	m.addmemory_cost = nil
}

// SetStatus sets the "status" field.
func (m *JudgeRecordMutation) SetStatus(i int64) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *JudgeRecordMutation) Status() (r int64, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the JudgeRecord entity.
// If the JudgeRecord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JudgeRecordMutation) OldStatus(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *JudgeRecordMutation) AddStatus(i int64) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *JudgeRecordMutation) AddedStatus() (r int64, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ResetStatus resets all changes to the "status" field.
func (m *JudgeRecordMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
}

// AddUserIDs adds the "user" edge to the User entity by ids.
func (m *JudgeRecordMutation) AddUserIDs(ids ...int64) {
	if m.user == nil {
		m.user = make(map[int64]struct{})
	}
	for i := range ids {
		m.user[ids[i]] = struct{}{}
	}
}

// ClearUser clears the "user" edge to the User entity.
func (m *JudgeRecordMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *JudgeRecordMutation) UserCleared() bool {
	return m.cleareduser
}

// RemoveUserIDs removes the "user" edge to the User entity by IDs.
func (m *JudgeRecordMutation) RemoveUserIDs(ids ...int64) {
	if m.removeduser == nil {
		m.removeduser = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.user, ids[i])
		m.removeduser[ids[i]] = struct{}{}
	}
}

// RemovedUser returns the removed IDs of the "user" edge to the User entity.
func (m *JudgeRecordMutation) RemovedUserIDs() (ids []int64) {
	for id := range m.removeduser {
		ids = append(ids, id)
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
func (m *JudgeRecordMutation) UserIDs() (ids []int64) {
	for id := range m.user {
		ids = append(ids, id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *JudgeRecordMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
	m.removeduser = nil
}

// Where appends a list predicates to the JudgeRecordMutation builder.
func (m *JudgeRecordMutation) Where(ps ...predicate.JudgeRecord) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *JudgeRecordMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (JudgeRecord).
func (m *JudgeRecordMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *JudgeRecordMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.judge_time != nil {
		fields = append(fields, judgerecord.FieldJudgeTime)
	}
	if m.finished_time != nil {
		fields = append(fields, judgerecord.FieldFinishedTime)
	}
	if m.time_cost != nil {
		fields = append(fields, judgerecord.FieldTimeCost)
	}
	if m.memory_cost != nil {
		fields = append(fields, judgerecord.FieldMemoryCost)
	}
	if m.status != nil {
		fields = append(fields, judgerecord.FieldStatus)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *JudgeRecordMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case judgerecord.FieldJudgeTime:
		return m.JudgeTime()
	case judgerecord.FieldFinishedTime:
		return m.FinishedTime()
	case judgerecord.FieldTimeCost:
		return m.TimeCost()
	case judgerecord.FieldMemoryCost:
		return m.MemoryCost()
	case judgerecord.FieldStatus:
		return m.Status()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *JudgeRecordMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case judgerecord.FieldJudgeTime:
		return m.OldJudgeTime(ctx)
	case judgerecord.FieldFinishedTime:
		return m.OldFinishedTime(ctx)
	case judgerecord.FieldTimeCost:
		return m.OldTimeCost(ctx)
	case judgerecord.FieldMemoryCost:
		return m.OldMemoryCost(ctx)
	case judgerecord.FieldStatus:
		return m.OldStatus(ctx)
	}
	return nil, fmt.Errorf("unknown JudgeRecord field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *JudgeRecordMutation) SetField(name string, value ent.Value) error {
	switch name {
	case judgerecord.FieldJudgeTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetJudgeTime(v)
		return nil
	case judgerecord.FieldFinishedTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFinishedTime(v)
		return nil
	case judgerecord.FieldTimeCost:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTimeCost(v)
		return nil
	case judgerecord.FieldMemoryCost:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMemoryCost(v)
		return nil
	case judgerecord.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	}
	return fmt.Errorf("unknown JudgeRecord field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *JudgeRecordMutation) AddedFields() []string {
	var fields []string
	if m.addtime_cost != nil {
		fields = append(fields, judgerecord.FieldTimeCost)
	}
	if m.addmemory_cost != nil {
		fields = append(fields, judgerecord.FieldMemoryCost)
	}
	if m.addstatus != nil {
		fields = append(fields, judgerecord.FieldStatus)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *JudgeRecordMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case judgerecord.FieldTimeCost:
		return m.AddedTimeCost()
	case judgerecord.FieldMemoryCost:
		return m.AddedMemoryCost()
	case judgerecord.FieldStatus:
		return m.AddedStatus()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *JudgeRecordMutation) AddField(name string, value ent.Value) error {
	switch name {
	case judgerecord.FieldTimeCost:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTimeCost(v)
		return nil
	case judgerecord.FieldMemoryCost:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMemoryCost(v)
		return nil
	case judgerecord.FieldStatus:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	}
	return fmt.Errorf("unknown JudgeRecord numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *JudgeRecordMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *JudgeRecordMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *JudgeRecordMutation) ClearField(name string) error {
	return fmt.Errorf("unknown JudgeRecord nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *JudgeRecordMutation) ResetField(name string) error {
	switch name {
	case judgerecord.FieldJudgeTime:
		m.ResetJudgeTime()
		return nil
	case judgerecord.FieldFinishedTime:
		m.ResetFinishedTime()
		return nil
	case judgerecord.FieldTimeCost:
		m.ResetTimeCost()
		return nil
	case judgerecord.FieldMemoryCost:
		m.ResetMemoryCost()
		return nil
	case judgerecord.FieldStatus:
		m.ResetStatus()
		return nil
	}
	return fmt.Errorf("unknown JudgeRecord field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *JudgeRecordMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user != nil {
		edges = append(edges, judgerecord.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *JudgeRecordMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case judgerecord.EdgeUser:
		ids := make([]ent.Value, 0, len(m.user))
		for id := range m.user {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *JudgeRecordMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removeduser != nil {
		edges = append(edges, judgerecord.EdgeUser)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *JudgeRecordMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case judgerecord.EdgeUser:
		ids := make([]ent.Value, 0, len(m.removeduser))
		for id := range m.removeduser {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *JudgeRecordMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser {
		edges = append(edges, judgerecord.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *JudgeRecordMutation) EdgeCleared(name string) bool {
	switch name {
	case judgerecord.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *JudgeRecordMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown JudgeRecord unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *JudgeRecordMutation) ResetEdge(name string) error {
	switch name {
	case judgerecord.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown JudgeRecord edge %s", name)
}

// ProblemMutation represents an operation that mutates the Problem nodes in the graph.
type ProblemMutation struct {
	config
	op               Op
	typ              string
	id               *int64
	title            *string
	content          *string
	created_time     *time.Time
	clearedFields    map[string]struct{}
	author           *int64
	clearedauthor    bool
	solved_by        map[int64]struct{}
	removedsolved_by map[int64]struct{}
	clearedsolved_by bool
	tags             map[int64]struct{}
	removedtags      map[int64]struct{}
	clearedtags      bool
	done             bool
	oldValue         func(context.Context) (*Problem, error)
	predicates       []predicate.Problem
}

var _ ent.Mutation = (*ProblemMutation)(nil)

// problemOption allows management of the mutation configuration using functional options.
type problemOption func(*ProblemMutation)

// newProblemMutation creates new mutation for the Problem entity.
func newProblemMutation(c config, op Op, opts ...problemOption) *ProblemMutation {
	m := &ProblemMutation{
		config:        c,
		op:            op,
		typ:           TypeProblem,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProblemID sets the ID field of the mutation.
func withProblemID(id int64) problemOption {
	return func(m *ProblemMutation) {
		var (
			err   error
			once  sync.Once
			value *Problem
		)
		m.oldValue = func(ctx context.Context) (*Problem, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Problem.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProblem sets the old Problem of the mutation.
func withProblem(node *Problem) problemOption {
	return func(m *ProblemMutation) {
		m.oldValue = func(context.Context) (*Problem, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProblemMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProblemMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Problem entities.
func (m *ProblemMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProblemMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ProblemMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Problem.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTitle sets the "title" field.
func (m *ProblemMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *ProblemMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the Problem entity.
// If the Problem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProblemMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *ProblemMutation) ResetTitle() {
	m.title = nil
}

// SetContent sets the "content" field.
func (m *ProblemMutation) SetContent(s string) {
	m.content = &s
}

// Content returns the value of the "content" field in the mutation.
func (m *ProblemMutation) Content() (r string, exists bool) {
	v := m.content
	if v == nil {
		return
	}
	return *v, true
}

// OldContent returns the old "content" field's value of the Problem entity.
// If the Problem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProblemMutation) OldContent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContent: %w", err)
	}
	return oldValue.Content, nil
}

// ResetContent resets all changes to the "content" field.
func (m *ProblemMutation) ResetContent() {
	m.content = nil
}

// SetCreatedTime sets the "created_time" field.
func (m *ProblemMutation) SetCreatedTime(t time.Time) {
	m.created_time = &t
}

// CreatedTime returns the value of the "created_time" field in the mutation.
func (m *ProblemMutation) CreatedTime() (r time.Time, exists bool) {
	v := m.created_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedTime returns the old "created_time" field's value of the Problem entity.
// If the Problem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProblemMutation) OldCreatedTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedTime: %w", err)
	}
	return oldValue.CreatedTime, nil
}

// ResetCreatedTime resets all changes to the "created_time" field.
func (m *ProblemMutation) ResetCreatedTime() {
	m.created_time = nil
}

// SetAuthorID sets the "author" edge to the User entity by id.
func (m *ProblemMutation) SetAuthorID(id int64) {
	m.author = &id
}

// ClearAuthor clears the "author" edge to the User entity.
func (m *ProblemMutation) ClearAuthor() {
	m.clearedauthor = true
}

// AuthorCleared reports if the "author" edge to the User entity was cleared.
func (m *ProblemMutation) AuthorCleared() bool {
	return m.clearedauthor
}

// AuthorID returns the "author" edge ID in the mutation.
func (m *ProblemMutation) AuthorID() (id int64, exists bool) {
	if m.author != nil {
		return *m.author, true
	}
	return
}

// AuthorIDs returns the "author" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AuthorID instead. It exists only for internal usage by the builders.
func (m *ProblemMutation) AuthorIDs() (ids []int64) {
	if id := m.author; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAuthor resets all changes to the "author" edge.
func (m *ProblemMutation) ResetAuthor() {
	m.author = nil
	m.clearedauthor = false
}

// AddSolvedByIDs adds the "solved_by" edge to the User entity by ids.
func (m *ProblemMutation) AddSolvedByIDs(ids ...int64) {
	if m.solved_by == nil {
		m.solved_by = make(map[int64]struct{})
	}
	for i := range ids {
		m.solved_by[ids[i]] = struct{}{}
	}
}

// ClearSolvedBy clears the "solved_by" edge to the User entity.
func (m *ProblemMutation) ClearSolvedBy() {
	m.clearedsolved_by = true
}

// SolvedByCleared reports if the "solved_by" edge to the User entity was cleared.
func (m *ProblemMutation) SolvedByCleared() bool {
	return m.clearedsolved_by
}

// RemoveSolvedByIDs removes the "solved_by" edge to the User entity by IDs.
func (m *ProblemMutation) RemoveSolvedByIDs(ids ...int64) {
	if m.removedsolved_by == nil {
		m.removedsolved_by = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.solved_by, ids[i])
		m.removedsolved_by[ids[i]] = struct{}{}
	}
}

// RemovedSolvedBy returns the removed IDs of the "solved_by" edge to the User entity.
func (m *ProblemMutation) RemovedSolvedByIDs() (ids []int64) {
	for id := range m.removedsolved_by {
		ids = append(ids, id)
	}
	return
}

// SolvedByIDs returns the "solved_by" edge IDs in the mutation.
func (m *ProblemMutation) SolvedByIDs() (ids []int64) {
	for id := range m.solved_by {
		ids = append(ids, id)
	}
	return
}

// ResetSolvedBy resets all changes to the "solved_by" edge.
func (m *ProblemMutation) ResetSolvedBy() {
	m.solved_by = nil
	m.clearedsolved_by = false
	m.removedsolved_by = nil
}

// AddTagIDs adds the "tags" edge to the Tag entity by ids.
func (m *ProblemMutation) AddTagIDs(ids ...int64) {
	if m.tags == nil {
		m.tags = make(map[int64]struct{})
	}
	for i := range ids {
		m.tags[ids[i]] = struct{}{}
	}
}

// ClearTags clears the "tags" edge to the Tag entity.
func (m *ProblemMutation) ClearTags() {
	m.clearedtags = true
}

// TagsCleared reports if the "tags" edge to the Tag entity was cleared.
func (m *ProblemMutation) TagsCleared() bool {
	return m.clearedtags
}

// RemoveTagIDs removes the "tags" edge to the Tag entity by IDs.
func (m *ProblemMutation) RemoveTagIDs(ids ...int64) {
	if m.removedtags == nil {
		m.removedtags = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.tags, ids[i])
		m.removedtags[ids[i]] = struct{}{}
	}
}

// RemovedTags returns the removed IDs of the "tags" edge to the Tag entity.
func (m *ProblemMutation) RemovedTagsIDs() (ids []int64) {
	for id := range m.removedtags {
		ids = append(ids, id)
	}
	return
}

// TagsIDs returns the "tags" edge IDs in the mutation.
func (m *ProblemMutation) TagsIDs() (ids []int64) {
	for id := range m.tags {
		ids = append(ids, id)
	}
	return
}

// ResetTags resets all changes to the "tags" edge.
func (m *ProblemMutation) ResetTags() {
	m.tags = nil
	m.clearedtags = false
	m.removedtags = nil
}

// Where appends a list predicates to the ProblemMutation builder.
func (m *ProblemMutation) Where(ps ...predicate.Problem) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *ProblemMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Problem).
func (m *ProblemMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProblemMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.title != nil {
		fields = append(fields, problem.FieldTitle)
	}
	if m.content != nil {
		fields = append(fields, problem.FieldContent)
	}
	if m.created_time != nil {
		fields = append(fields, problem.FieldCreatedTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProblemMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case problem.FieldTitle:
		return m.Title()
	case problem.FieldContent:
		return m.Content()
	case problem.FieldCreatedTime:
		return m.CreatedTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProblemMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case problem.FieldTitle:
		return m.OldTitle(ctx)
	case problem.FieldContent:
		return m.OldContent(ctx)
	case problem.FieldCreatedTime:
		return m.OldCreatedTime(ctx)
	}
	return nil, fmt.Errorf("unknown Problem field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProblemMutation) SetField(name string, value ent.Value) error {
	switch name {
	case problem.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case problem.FieldContent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContent(v)
		return nil
	case problem.FieldCreatedTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedTime(v)
		return nil
	}
	return fmt.Errorf("unknown Problem field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProblemMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProblemMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProblemMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Problem numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProblemMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProblemMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProblemMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Problem nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProblemMutation) ResetField(name string) error {
	switch name {
	case problem.FieldTitle:
		m.ResetTitle()
		return nil
	case problem.FieldContent:
		m.ResetContent()
		return nil
	case problem.FieldCreatedTime:
		m.ResetCreatedTime()
		return nil
	}
	return fmt.Errorf("unknown Problem field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProblemMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.author != nil {
		edges = append(edges, problem.EdgeAuthor)
	}
	if m.solved_by != nil {
		edges = append(edges, problem.EdgeSolvedBy)
	}
	if m.tags != nil {
		edges = append(edges, problem.EdgeTags)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProblemMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case problem.EdgeAuthor:
		if id := m.author; id != nil {
			return []ent.Value{*id}
		}
	case problem.EdgeSolvedBy:
		ids := make([]ent.Value, 0, len(m.solved_by))
		for id := range m.solved_by {
			ids = append(ids, id)
		}
		return ids
	case problem.EdgeTags:
		ids := make([]ent.Value, 0, len(m.tags))
		for id := range m.tags {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProblemMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedsolved_by != nil {
		edges = append(edges, problem.EdgeSolvedBy)
	}
	if m.removedtags != nil {
		edges = append(edges, problem.EdgeTags)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProblemMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case problem.EdgeSolvedBy:
		ids := make([]ent.Value, 0, len(m.removedsolved_by))
		for id := range m.removedsolved_by {
			ids = append(ids, id)
		}
		return ids
	case problem.EdgeTags:
		ids := make([]ent.Value, 0, len(m.removedtags))
		for id := range m.removedtags {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProblemMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedauthor {
		edges = append(edges, problem.EdgeAuthor)
	}
	if m.clearedsolved_by {
		edges = append(edges, problem.EdgeSolvedBy)
	}
	if m.clearedtags {
		edges = append(edges, problem.EdgeTags)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProblemMutation) EdgeCleared(name string) bool {
	switch name {
	case problem.EdgeAuthor:
		return m.clearedauthor
	case problem.EdgeSolvedBy:
		return m.clearedsolved_by
	case problem.EdgeTags:
		return m.clearedtags
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProblemMutation) ClearEdge(name string) error {
	switch name {
	case problem.EdgeAuthor:
		m.ClearAuthor()
		return nil
	}
	return fmt.Errorf("unknown Problem unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProblemMutation) ResetEdge(name string) error {
	switch name {
	case problem.EdgeAuthor:
		m.ResetAuthor()
		return nil
	case problem.EdgeSolvedBy:
		m.ResetSolvedBy()
		return nil
	case problem.EdgeTags:
		m.ResetTags()
		return nil
	}
	return fmt.Errorf("unknown Problem edge %s", name)
}

// TagMutation represents an operation that mutates the Tag nodes in the graph.
type TagMutation struct {
	config
	op              Op
	typ             string
	id              *int64
	name            *string
	created_time    *time.Time
	clearedFields   map[string]struct{}
	problems        map[int64]struct{}
	removedproblems map[int64]struct{}
	clearedproblems bool
	done            bool
	oldValue        func(context.Context) (*Tag, error)
	predicates      []predicate.Tag
}

var _ ent.Mutation = (*TagMutation)(nil)

// tagOption allows management of the mutation configuration using functional options.
type tagOption func(*TagMutation)

// newTagMutation creates new mutation for the Tag entity.
func newTagMutation(c config, op Op, opts ...tagOption) *TagMutation {
	m := &TagMutation{
		config:        c,
		op:            op,
		typ:           TypeTag,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTagID sets the ID field of the mutation.
func withTagID(id int64) tagOption {
	return func(m *TagMutation) {
		var (
			err   error
			once  sync.Once
			value *Tag
		)
		m.oldValue = func(ctx context.Context) (*Tag, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Tag.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTag sets the old Tag of the mutation.
func withTag(node *Tag) tagOption {
	return func(m *TagMutation) {
		m.oldValue = func(context.Context) (*Tag, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TagMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TagMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Tag entities.
func (m *TagMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TagMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TagMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Tag.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *TagMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *TagMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Tag entity.
// If the Tag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TagMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *TagMutation) ResetName() {
	m.name = nil
}

// SetCreatedTime sets the "created_time" field.
func (m *TagMutation) SetCreatedTime(t time.Time) {
	m.created_time = &t
}

// CreatedTime returns the value of the "created_time" field in the mutation.
func (m *TagMutation) CreatedTime() (r time.Time, exists bool) {
	v := m.created_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedTime returns the old "created_time" field's value of the Tag entity.
// If the Tag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TagMutation) OldCreatedTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedTime: %w", err)
	}
	return oldValue.CreatedTime, nil
}

// ResetCreatedTime resets all changes to the "created_time" field.
func (m *TagMutation) ResetCreatedTime() {
	m.created_time = nil
}

// AddProblemIDs adds the "problems" edge to the Problem entity by ids.
func (m *TagMutation) AddProblemIDs(ids ...int64) {
	if m.problems == nil {
		m.problems = make(map[int64]struct{})
	}
	for i := range ids {
		m.problems[ids[i]] = struct{}{}
	}
}

// ClearProblems clears the "problems" edge to the Problem entity.
func (m *TagMutation) ClearProblems() {
	m.clearedproblems = true
}

// ProblemsCleared reports if the "problems" edge to the Problem entity was cleared.
func (m *TagMutation) ProblemsCleared() bool {
	return m.clearedproblems
}

// RemoveProblemIDs removes the "problems" edge to the Problem entity by IDs.
func (m *TagMutation) RemoveProblemIDs(ids ...int64) {
	if m.removedproblems == nil {
		m.removedproblems = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.problems, ids[i])
		m.removedproblems[ids[i]] = struct{}{}
	}
}

// RemovedProblems returns the removed IDs of the "problems" edge to the Problem entity.
func (m *TagMutation) RemovedProblemsIDs() (ids []int64) {
	for id := range m.removedproblems {
		ids = append(ids, id)
	}
	return
}

// ProblemsIDs returns the "problems" edge IDs in the mutation.
func (m *TagMutation) ProblemsIDs() (ids []int64) {
	for id := range m.problems {
		ids = append(ids, id)
	}
	return
}

// ResetProblems resets all changes to the "problems" edge.
func (m *TagMutation) ResetProblems() {
	m.problems = nil
	m.clearedproblems = false
	m.removedproblems = nil
}

// Where appends a list predicates to the TagMutation builder.
func (m *TagMutation) Where(ps ...predicate.Tag) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *TagMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Tag).
func (m *TagMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TagMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.name != nil {
		fields = append(fields, tag.FieldName)
	}
	if m.created_time != nil {
		fields = append(fields, tag.FieldCreatedTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TagMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case tag.FieldName:
		return m.Name()
	case tag.FieldCreatedTime:
		return m.CreatedTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TagMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case tag.FieldName:
		return m.OldName(ctx)
	case tag.FieldCreatedTime:
		return m.OldCreatedTime(ctx)
	}
	return nil, fmt.Errorf("unknown Tag field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TagMutation) SetField(name string, value ent.Value) error {
	switch name {
	case tag.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case tag.FieldCreatedTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedTime(v)
		return nil
	}
	return fmt.Errorf("unknown Tag field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TagMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TagMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TagMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Tag numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TagMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TagMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TagMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Tag nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TagMutation) ResetField(name string) error {
	switch name {
	case tag.FieldName:
		m.ResetName()
		return nil
	case tag.FieldCreatedTime:
		m.ResetCreatedTime()
		return nil
	}
	return fmt.Errorf("unknown Tag field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TagMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.problems != nil {
		edges = append(edges, tag.EdgeProblems)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TagMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case tag.EdgeProblems:
		ids := make([]ent.Value, 0, len(m.problems))
		for id := range m.problems {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TagMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedproblems != nil {
		edges = append(edges, tag.EdgeProblems)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TagMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case tag.EdgeProblems:
		ids := make([]ent.Value, 0, len(m.removedproblems))
		for id := range m.removedproblems {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TagMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedproblems {
		edges = append(edges, tag.EdgeProblems)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TagMutation) EdgeCleared(name string) bool {
	switch name {
	case tag.EdgeProblems:
		return m.clearedproblems
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TagMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Tag unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TagMutation) ResetEdge(name string) error {
	switch name {
	case tag.EdgeProblems:
		m.ResetProblems()
		return nil
	}
	return fmt.Errorf("unknown Tag edge %s", name)
}

// TeamMutation represents an operation that mutates the Team nodes in the graph.
type TeamMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int64
	name                 *string
	created_time         *time.Time
	clearedFields        map[string]struct{}
	members              map[int64]struct{}
	removedmembers       map[int64]struct{}
	clearedmembers       bool
	announcements        map[int64]struct{}
	removedannouncements map[int64]struct{}
	clearedannouncements bool
	done                 bool
	oldValue             func(context.Context) (*Team, error)
	predicates           []predicate.Team
}

var _ ent.Mutation = (*TeamMutation)(nil)

// teamOption allows management of the mutation configuration using functional options.
type teamOption func(*TeamMutation)

// newTeamMutation creates new mutation for the Team entity.
func newTeamMutation(c config, op Op, opts ...teamOption) *TeamMutation {
	m := &TeamMutation{
		config:        c,
		op:            op,
		typ:           TypeTeam,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTeamID sets the ID field of the mutation.
func withTeamID(id int64) teamOption {
	return func(m *TeamMutation) {
		var (
			err   error
			once  sync.Once
			value *Team
		)
		m.oldValue = func(ctx context.Context) (*Team, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Team.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTeam sets the old Team of the mutation.
func withTeam(node *Team) teamOption {
	return func(m *TeamMutation) {
		m.oldValue = func(context.Context) (*Team, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TeamMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TeamMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Team entities.
func (m *TeamMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TeamMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TeamMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Team.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *TeamMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *TeamMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Team entity.
// If the Team object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeamMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *TeamMutation) ResetName() {
	m.name = nil
}

// SetCreatedTime sets the "created_time" field.
func (m *TeamMutation) SetCreatedTime(t time.Time) {
	m.created_time = &t
}

// CreatedTime returns the value of the "created_time" field in the mutation.
func (m *TeamMutation) CreatedTime() (r time.Time, exists bool) {
	v := m.created_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedTime returns the old "created_time" field's value of the Team entity.
// If the Team object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeamMutation) OldCreatedTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedTime: %w", err)
	}
	return oldValue.CreatedTime, nil
}

// ResetCreatedTime resets all changes to the "created_time" field.
func (m *TeamMutation) ResetCreatedTime() {
	m.created_time = nil
}

// AddMemberIDs adds the "members" edge to the User entity by ids.
func (m *TeamMutation) AddMemberIDs(ids ...int64) {
	if m.members == nil {
		m.members = make(map[int64]struct{})
	}
	for i := range ids {
		m.members[ids[i]] = struct{}{}
	}
}

// ClearMembers clears the "members" edge to the User entity.
func (m *TeamMutation) ClearMembers() {
	m.clearedmembers = true
}

// MembersCleared reports if the "members" edge to the User entity was cleared.
func (m *TeamMutation) MembersCleared() bool {
	return m.clearedmembers
}

// RemoveMemberIDs removes the "members" edge to the User entity by IDs.
func (m *TeamMutation) RemoveMemberIDs(ids ...int64) {
	if m.removedmembers == nil {
		m.removedmembers = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.members, ids[i])
		m.removedmembers[ids[i]] = struct{}{}
	}
}

// RemovedMembers returns the removed IDs of the "members" edge to the User entity.
func (m *TeamMutation) RemovedMembersIDs() (ids []int64) {
	for id := range m.removedmembers {
		ids = append(ids, id)
	}
	return
}

// MembersIDs returns the "members" edge IDs in the mutation.
func (m *TeamMutation) MembersIDs() (ids []int64) {
	for id := range m.members {
		ids = append(ids, id)
	}
	return
}

// ResetMembers resets all changes to the "members" edge.
func (m *TeamMutation) ResetMembers() {
	m.members = nil
	m.clearedmembers = false
	m.removedmembers = nil
}

// AddAnnouncementIDs adds the "announcements" edge to the Announcement entity by ids.
func (m *TeamMutation) AddAnnouncementIDs(ids ...int64) {
	if m.announcements == nil {
		m.announcements = make(map[int64]struct{})
	}
	for i := range ids {
		m.announcements[ids[i]] = struct{}{}
	}
}

// ClearAnnouncements clears the "announcements" edge to the Announcement entity.
func (m *TeamMutation) ClearAnnouncements() {
	m.clearedannouncements = true
}

// AnnouncementsCleared reports if the "announcements" edge to the Announcement entity was cleared.
func (m *TeamMutation) AnnouncementsCleared() bool {
	return m.clearedannouncements
}

// RemoveAnnouncementIDs removes the "announcements" edge to the Announcement entity by IDs.
func (m *TeamMutation) RemoveAnnouncementIDs(ids ...int64) {
	if m.removedannouncements == nil {
		m.removedannouncements = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.announcements, ids[i])
		m.removedannouncements[ids[i]] = struct{}{}
	}
}

// RemovedAnnouncements returns the removed IDs of the "announcements" edge to the Announcement entity.
func (m *TeamMutation) RemovedAnnouncementsIDs() (ids []int64) {
	for id := range m.removedannouncements {
		ids = append(ids, id)
	}
	return
}

// AnnouncementsIDs returns the "announcements" edge IDs in the mutation.
func (m *TeamMutation) AnnouncementsIDs() (ids []int64) {
	for id := range m.announcements {
		ids = append(ids, id)
	}
	return
}

// ResetAnnouncements resets all changes to the "announcements" edge.
func (m *TeamMutation) ResetAnnouncements() {
	m.announcements = nil
	m.clearedannouncements = false
	m.removedannouncements = nil
}

// Where appends a list predicates to the TeamMutation builder.
func (m *TeamMutation) Where(ps ...predicate.Team) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *TeamMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Team).
func (m *TeamMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TeamMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.name != nil {
		fields = append(fields, team.FieldName)
	}
	if m.created_time != nil {
		fields = append(fields, team.FieldCreatedTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TeamMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case team.FieldName:
		return m.Name()
	case team.FieldCreatedTime:
		return m.CreatedTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TeamMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case team.FieldName:
		return m.OldName(ctx)
	case team.FieldCreatedTime:
		return m.OldCreatedTime(ctx)
	}
	return nil, fmt.Errorf("unknown Team field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TeamMutation) SetField(name string, value ent.Value) error {
	switch name {
	case team.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case team.FieldCreatedTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedTime(v)
		return nil
	}
	return fmt.Errorf("unknown Team field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TeamMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TeamMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TeamMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Team numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TeamMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TeamMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TeamMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Team nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TeamMutation) ResetField(name string) error {
	switch name {
	case team.FieldName:
		m.ResetName()
		return nil
	case team.FieldCreatedTime:
		m.ResetCreatedTime()
		return nil
	}
	return fmt.Errorf("unknown Team field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TeamMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.members != nil {
		edges = append(edges, team.EdgeMembers)
	}
	if m.announcements != nil {
		edges = append(edges, team.EdgeAnnouncements)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TeamMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case team.EdgeMembers:
		ids := make([]ent.Value, 0, len(m.members))
		for id := range m.members {
			ids = append(ids, id)
		}
		return ids
	case team.EdgeAnnouncements:
		ids := make([]ent.Value, 0, len(m.announcements))
		for id := range m.announcements {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TeamMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedmembers != nil {
		edges = append(edges, team.EdgeMembers)
	}
	if m.removedannouncements != nil {
		edges = append(edges, team.EdgeAnnouncements)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TeamMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case team.EdgeMembers:
		ids := make([]ent.Value, 0, len(m.removedmembers))
		for id := range m.removedmembers {
			ids = append(ids, id)
		}
		return ids
	case team.EdgeAnnouncements:
		ids := make([]ent.Value, 0, len(m.removedannouncements))
		for id := range m.removedannouncements {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TeamMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedmembers {
		edges = append(edges, team.EdgeMembers)
	}
	if m.clearedannouncements {
		edges = append(edges, team.EdgeAnnouncements)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TeamMutation) EdgeCleared(name string) bool {
	switch name {
	case team.EdgeMembers:
		return m.clearedmembers
	case team.EdgeAnnouncements:
		return m.clearedannouncements
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TeamMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Team unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TeamMutation) ResetEdge(name string) error {
	switch name {
	case team.EdgeMembers:
		m.ResetMembers()
		return nil
	case team.EdgeAnnouncements:
		m.ResetAnnouncements()
		return nil
	}
	return fmt.Errorf("unknown Team edge %s", name)
}

// TodoMutation represents an operation that mutates the Todo nodes in the graph.
type TodoMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	text          *string
	_done         *bool
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Todo, error)
	predicates    []predicate.Todo
}

var _ ent.Mutation = (*TodoMutation)(nil)

// todoOption allows management of the mutation configuration using functional options.
type todoOption func(*TodoMutation)

// newTodoMutation creates new mutation for the Todo entity.
func newTodoMutation(c config, op Op, opts ...todoOption) *TodoMutation {
	m := &TodoMutation{
		config:        c,
		op:            op,
		typ:           TypeTodo,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTodoID sets the ID field of the mutation.
func withTodoID(id int64) todoOption {
	return func(m *TodoMutation) {
		var (
			err   error
			once  sync.Once
			value *Todo
		)
		m.oldValue = func(ctx context.Context) (*Todo, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Todo.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTodo sets the old Todo of the mutation.
func withTodo(node *Todo) todoOption {
	return func(m *TodoMutation) {
		m.oldValue = func(context.Context) (*Todo, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TodoMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TodoMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Todo entities.
func (m *TodoMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TodoMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TodoMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Todo.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetText sets the "text" field.
func (m *TodoMutation) SetText(s string) {
	m.text = &s
}

// Text returns the value of the "text" field in the mutation.
func (m *TodoMutation) Text() (r string, exists bool) {
	v := m.text
	if v == nil {
		return
	}
	return *v, true
}

// OldText returns the old "text" field's value of the Todo entity.
// If the Todo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TodoMutation) OldText(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldText is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldText requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldText: %w", err)
	}
	return oldValue.Text, nil
}

// ResetText resets all changes to the "text" field.
func (m *TodoMutation) ResetText() {
	m.text = nil
}

// SetDone sets the "done" field.
func (m *TodoMutation) SetDone(b bool) {
	m._done = &b
}

// Done returns the value of the "done" field in the mutation.
func (m *TodoMutation) Done() (r bool, exists bool) {
	v := m._done
	if v == nil {
		return
	}
	return *v, true
}

// OldDone returns the old "done" field's value of the Todo entity.
// If the Todo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TodoMutation) OldDone(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDone is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDone: %w", err)
	}
	return oldValue.Done, nil
}

// ResetDone resets all changes to the "done" field.
func (m *TodoMutation) ResetDone() {
	m._done = nil
}

// Where appends a list predicates to the TodoMutation builder.
func (m *TodoMutation) Where(ps ...predicate.Todo) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *TodoMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Todo).
func (m *TodoMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TodoMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.text != nil {
		fields = append(fields, todo.FieldText)
	}
	if m._done != nil {
		fields = append(fields, todo.FieldDone)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TodoMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case todo.FieldText:
		return m.Text()
	case todo.FieldDone:
		return m.Done()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TodoMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case todo.FieldText:
		return m.OldText(ctx)
	case todo.FieldDone:
		return m.OldDone(ctx)
	}
	return nil, fmt.Errorf("unknown Todo field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TodoMutation) SetField(name string, value ent.Value) error {
	switch name {
	case todo.FieldText:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetText(v)
		return nil
	case todo.FieldDone:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDone(v)
		return nil
	}
	return fmt.Errorf("unknown Todo field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TodoMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TodoMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TodoMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Todo numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TodoMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TodoMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TodoMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Todo nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TodoMutation) ResetField(name string) error {
	switch name {
	case todo.FieldText:
		m.ResetText()
		return nil
	case todo.FieldDone:
		m.ResetDone()
		return nil
	}
	return fmt.Errorf("unknown Todo field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TodoMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TodoMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TodoMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TodoMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TodoMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TodoMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TodoMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Todo unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TodoMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Todo edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op                      Op
	typ                     string
	id                      *int64
	nickname                *string
	email                   *string
	password                *string
	avatar                  *string
	created_time            *time.Time
	clearedFields           map[string]struct{}
	teams                   map[int64]struct{}
	removedteams            map[int64]struct{}
	clearedteams            bool
	announcements           *int64
	clearedannouncements    bool
	records                 *int64
	clearedrecords          bool
	created_problems        map[int64]struct{}
	removedcreated_problems map[int64]struct{}
	clearedcreated_problems bool
	solved_problems         map[int64]struct{}
	removedsolved_problems  map[int64]struct{}
	clearedsolved_problems  bool
	done                    bool
	oldValue                func(context.Context) (*User, error)
	predicates              []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id int64) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of User entities.
func (m *UserMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().User.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetNickname sets the "nickname" field.
func (m *UserMutation) SetNickname(s string) {
	m.nickname = &s
}

// Nickname returns the value of the "nickname" field in the mutation.
func (m *UserMutation) Nickname() (r string, exists bool) {
	v := m.nickname
	if v == nil {
		return
	}
	return *v, true
}

// OldNickname returns the old "nickname" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldNickname(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNickname is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNickname requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNickname: %w", err)
	}
	return oldValue.Nickname, nil
}

// ResetNickname resets all changes to the "nickname" field.
func (m *UserMutation) ResetNickname() {
	m.nickname = nil
}

// SetEmail sets the "email" field.
func (m *UserMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *UserMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *UserMutation) ResetEmail() {
	m.email = nil
}

// SetPassword sets the "password" field.
func (m *UserMutation) SetPassword(s string) {
	m.password = &s
}

// Password returns the value of the "password" field in the mutation.
func (m *UserMutation) Password() (r string, exists bool) {
	v := m.password
	if v == nil {
		return
	}
	return *v, true
}

// OldPassword returns the old "password" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPassword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPassword: %w", err)
	}
	return oldValue.Password, nil
}

// ResetPassword resets all changes to the "password" field.
func (m *UserMutation) ResetPassword() {
	m.password = nil
}

// SetAvatar sets the "avatar" field.
func (m *UserMutation) SetAvatar(s string) {
	m.avatar = &s
}

// Avatar returns the value of the "avatar" field in the mutation.
func (m *UserMutation) Avatar() (r string, exists bool) {
	v := m.avatar
	if v == nil {
		return
	}
	return *v, true
}

// OldAvatar returns the old "avatar" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldAvatar(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAvatar is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAvatar requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAvatar: %w", err)
	}
	return oldValue.Avatar, nil
}

// ResetAvatar resets all changes to the "avatar" field.
func (m *UserMutation) ResetAvatar() {
	m.avatar = nil
}

// SetCreatedTime sets the "created_time" field.
func (m *UserMutation) SetCreatedTime(t time.Time) {
	m.created_time = &t
}

// CreatedTime returns the value of the "created_time" field in the mutation.
func (m *UserMutation) CreatedTime() (r time.Time, exists bool) {
	v := m.created_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedTime returns the old "created_time" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCreatedTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedTime: %w", err)
	}
	return oldValue.CreatedTime, nil
}

// ResetCreatedTime resets all changes to the "created_time" field.
func (m *UserMutation) ResetCreatedTime() {
	m.created_time = nil
}

// AddTeamIDs adds the "teams" edge to the Team entity by ids.
func (m *UserMutation) AddTeamIDs(ids ...int64) {
	if m.teams == nil {
		m.teams = make(map[int64]struct{})
	}
	for i := range ids {
		m.teams[ids[i]] = struct{}{}
	}
}

// ClearTeams clears the "teams" edge to the Team entity.
func (m *UserMutation) ClearTeams() {
	m.clearedteams = true
}

// TeamsCleared reports if the "teams" edge to the Team entity was cleared.
func (m *UserMutation) TeamsCleared() bool {
	return m.clearedteams
}

// RemoveTeamIDs removes the "teams" edge to the Team entity by IDs.
func (m *UserMutation) RemoveTeamIDs(ids ...int64) {
	if m.removedteams == nil {
		m.removedteams = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.teams, ids[i])
		m.removedteams[ids[i]] = struct{}{}
	}
}

// RemovedTeams returns the removed IDs of the "teams" edge to the Team entity.
func (m *UserMutation) RemovedTeamsIDs() (ids []int64) {
	for id := range m.removedteams {
		ids = append(ids, id)
	}
	return
}

// TeamsIDs returns the "teams" edge IDs in the mutation.
func (m *UserMutation) TeamsIDs() (ids []int64) {
	for id := range m.teams {
		ids = append(ids, id)
	}
	return
}

// ResetTeams resets all changes to the "teams" edge.
func (m *UserMutation) ResetTeams() {
	m.teams = nil
	m.clearedteams = false
	m.removedteams = nil
}

// SetAnnouncementsID sets the "announcements" edge to the Announcement entity by id.
func (m *UserMutation) SetAnnouncementsID(id int64) {
	m.announcements = &id
}

// ClearAnnouncements clears the "announcements" edge to the Announcement entity.
func (m *UserMutation) ClearAnnouncements() {
	m.clearedannouncements = true
}

// AnnouncementsCleared reports if the "announcements" edge to the Announcement entity was cleared.
func (m *UserMutation) AnnouncementsCleared() bool {
	return m.clearedannouncements
}

// AnnouncementsID returns the "announcements" edge ID in the mutation.
func (m *UserMutation) AnnouncementsID() (id int64, exists bool) {
	if m.announcements != nil {
		return *m.announcements, true
	}
	return
}

// AnnouncementsIDs returns the "announcements" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AnnouncementsID instead. It exists only for internal usage by the builders.
func (m *UserMutation) AnnouncementsIDs() (ids []int64) {
	if id := m.announcements; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAnnouncements resets all changes to the "announcements" edge.
func (m *UserMutation) ResetAnnouncements() {
	m.announcements = nil
	m.clearedannouncements = false
}

// SetRecordsID sets the "records" edge to the JudgeRecord entity by id.
func (m *UserMutation) SetRecordsID(id int64) {
	m.records = &id
}

// ClearRecords clears the "records" edge to the JudgeRecord entity.
func (m *UserMutation) ClearRecords() {
	m.clearedrecords = true
}

// RecordsCleared reports if the "records" edge to the JudgeRecord entity was cleared.
func (m *UserMutation) RecordsCleared() bool {
	return m.clearedrecords
}

// RecordsID returns the "records" edge ID in the mutation.
func (m *UserMutation) RecordsID() (id int64, exists bool) {
	if m.records != nil {
		return *m.records, true
	}
	return
}

// RecordsIDs returns the "records" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RecordsID instead. It exists only for internal usage by the builders.
func (m *UserMutation) RecordsIDs() (ids []int64) {
	if id := m.records; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRecords resets all changes to the "records" edge.
func (m *UserMutation) ResetRecords() {
	m.records = nil
	m.clearedrecords = false
}

// AddCreatedProblemIDs adds the "created_problems" edge to the Problem entity by ids.
func (m *UserMutation) AddCreatedProblemIDs(ids ...int64) {
	if m.created_problems == nil {
		m.created_problems = make(map[int64]struct{})
	}
	for i := range ids {
		m.created_problems[ids[i]] = struct{}{}
	}
}

// ClearCreatedProblems clears the "created_problems" edge to the Problem entity.
func (m *UserMutation) ClearCreatedProblems() {
	m.clearedcreated_problems = true
}

// CreatedProblemsCleared reports if the "created_problems" edge to the Problem entity was cleared.
func (m *UserMutation) CreatedProblemsCleared() bool {
	return m.clearedcreated_problems
}

// RemoveCreatedProblemIDs removes the "created_problems" edge to the Problem entity by IDs.
func (m *UserMutation) RemoveCreatedProblemIDs(ids ...int64) {
	if m.removedcreated_problems == nil {
		m.removedcreated_problems = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.created_problems, ids[i])
		m.removedcreated_problems[ids[i]] = struct{}{}
	}
}

// RemovedCreatedProblems returns the removed IDs of the "created_problems" edge to the Problem entity.
func (m *UserMutation) RemovedCreatedProblemsIDs() (ids []int64) {
	for id := range m.removedcreated_problems {
		ids = append(ids, id)
	}
	return
}

// CreatedProblemsIDs returns the "created_problems" edge IDs in the mutation.
func (m *UserMutation) CreatedProblemsIDs() (ids []int64) {
	for id := range m.created_problems {
		ids = append(ids, id)
	}
	return
}

// ResetCreatedProblems resets all changes to the "created_problems" edge.
func (m *UserMutation) ResetCreatedProblems() {
	m.created_problems = nil
	m.clearedcreated_problems = false
	m.removedcreated_problems = nil
}

// AddSolvedProblemIDs adds the "solved_problems" edge to the Problem entity by ids.
func (m *UserMutation) AddSolvedProblemIDs(ids ...int64) {
	if m.solved_problems == nil {
		m.solved_problems = make(map[int64]struct{})
	}
	for i := range ids {
		m.solved_problems[ids[i]] = struct{}{}
	}
}

// ClearSolvedProblems clears the "solved_problems" edge to the Problem entity.
func (m *UserMutation) ClearSolvedProblems() {
	m.clearedsolved_problems = true
}

// SolvedProblemsCleared reports if the "solved_problems" edge to the Problem entity was cleared.
func (m *UserMutation) SolvedProblemsCleared() bool {
	return m.clearedsolved_problems
}

// RemoveSolvedProblemIDs removes the "solved_problems" edge to the Problem entity by IDs.
func (m *UserMutation) RemoveSolvedProblemIDs(ids ...int64) {
	if m.removedsolved_problems == nil {
		m.removedsolved_problems = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.solved_problems, ids[i])
		m.removedsolved_problems[ids[i]] = struct{}{}
	}
}

// RemovedSolvedProblems returns the removed IDs of the "solved_problems" edge to the Problem entity.
func (m *UserMutation) RemovedSolvedProblemsIDs() (ids []int64) {
	for id := range m.removedsolved_problems {
		ids = append(ids, id)
	}
	return
}

// SolvedProblemsIDs returns the "solved_problems" edge IDs in the mutation.
func (m *UserMutation) SolvedProblemsIDs() (ids []int64) {
	for id := range m.solved_problems {
		ids = append(ids, id)
	}
	return
}

// ResetSolvedProblems resets all changes to the "solved_problems" edge.
func (m *UserMutation) ResetSolvedProblems() {
	m.solved_problems = nil
	m.clearedsolved_problems = false
	m.removedsolved_problems = nil
}

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.nickname != nil {
		fields = append(fields, user.FieldNickname)
	}
	if m.email != nil {
		fields = append(fields, user.FieldEmail)
	}
	if m.password != nil {
		fields = append(fields, user.FieldPassword)
	}
	if m.avatar != nil {
		fields = append(fields, user.FieldAvatar)
	}
	if m.created_time != nil {
		fields = append(fields, user.FieldCreatedTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldNickname:
		return m.Nickname()
	case user.FieldEmail:
		return m.Email()
	case user.FieldPassword:
		return m.Password()
	case user.FieldAvatar:
		return m.Avatar()
	case user.FieldCreatedTime:
		return m.CreatedTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldNickname:
		return m.OldNickname(ctx)
	case user.FieldEmail:
		return m.OldEmail(ctx)
	case user.FieldPassword:
		return m.OldPassword(ctx)
	case user.FieldAvatar:
		return m.OldAvatar(ctx)
	case user.FieldCreatedTime:
		return m.OldCreatedTime(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldNickname:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNickname(v)
		return nil
	case user.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case user.FieldPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPassword(v)
		return nil
	case user.FieldAvatar:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAvatar(v)
		return nil
	case user.FieldCreatedTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedTime(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldNickname:
		m.ResetNickname()
		return nil
	case user.FieldEmail:
		m.ResetEmail()
		return nil
	case user.FieldPassword:
		m.ResetPassword()
		return nil
	case user.FieldAvatar:
		m.ResetAvatar()
		return nil
	case user.FieldCreatedTime:
		m.ResetCreatedTime()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.teams != nil {
		edges = append(edges, user.EdgeTeams)
	}
	if m.announcements != nil {
		edges = append(edges, user.EdgeAnnouncements)
	}
	if m.records != nil {
		edges = append(edges, user.EdgeRecords)
	}
	if m.created_problems != nil {
		edges = append(edges, user.EdgeCreatedProblems)
	}
	if m.solved_problems != nil {
		edges = append(edges, user.EdgeSolvedProblems)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeTeams:
		ids := make([]ent.Value, 0, len(m.teams))
		for id := range m.teams {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeAnnouncements:
		if id := m.announcements; id != nil {
			return []ent.Value{*id}
		}
	case user.EdgeRecords:
		if id := m.records; id != nil {
			return []ent.Value{*id}
		}
	case user.EdgeCreatedProblems:
		ids := make([]ent.Value, 0, len(m.created_problems))
		for id := range m.created_problems {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeSolvedProblems:
		ids := make([]ent.Value, 0, len(m.solved_problems))
		for id := range m.solved_problems {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	if m.removedteams != nil {
		edges = append(edges, user.EdgeTeams)
	}
	if m.removedcreated_problems != nil {
		edges = append(edges, user.EdgeCreatedProblems)
	}
	if m.removedsolved_problems != nil {
		edges = append(edges, user.EdgeSolvedProblems)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeTeams:
		ids := make([]ent.Value, 0, len(m.removedteams))
		for id := range m.removedteams {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeCreatedProblems:
		ids := make([]ent.Value, 0, len(m.removedcreated_problems))
		for id := range m.removedcreated_problems {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeSolvedProblems:
		ids := make([]ent.Value, 0, len(m.removedsolved_problems))
		for id := range m.removedsolved_problems {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.clearedteams {
		edges = append(edges, user.EdgeTeams)
	}
	if m.clearedannouncements {
		edges = append(edges, user.EdgeAnnouncements)
	}
	if m.clearedrecords {
		edges = append(edges, user.EdgeRecords)
	}
	if m.clearedcreated_problems {
		edges = append(edges, user.EdgeCreatedProblems)
	}
	if m.clearedsolved_problems {
		edges = append(edges, user.EdgeSolvedProblems)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	switch name {
	case user.EdgeTeams:
		return m.clearedteams
	case user.EdgeAnnouncements:
		return m.clearedannouncements
	case user.EdgeRecords:
		return m.clearedrecords
	case user.EdgeCreatedProblems:
		return m.clearedcreated_problems
	case user.EdgeSolvedProblems:
		return m.clearedsolved_problems
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	switch name {
	case user.EdgeAnnouncements:
		m.ClearAnnouncements()
		return nil
	case user.EdgeRecords:
		m.ClearRecords()
		return nil
	}
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	switch name {
	case user.EdgeTeams:
		m.ResetTeams()
		return nil
	case user.EdgeAnnouncements:
		m.ResetAnnouncements()
		return nil
	case user.EdgeRecords:
		m.ResetRecords()
		return nil
	case user.EdgeCreatedProblems:
		m.ResetCreatedProblems()
		return nil
	case user.EdgeSolvedProblems:
		m.ResetSolvedProblems()
		return nil
	}
	return fmt.Errorf("unknown User edge %s", name)
}
